#!/bin/zsh

go_to() {
	case $(file --brief $1) in
		*directory*)
			cd $1
			;;
		*text*)
			vim $1
			;;
		*)
			open $1
			;;
	esac
}

update_position() {
	let "current_line = $1"
	if [ $current_line -gt $number_of_lines ]; then
		let "current_line = $number_of_lines"
	elif [ $current_line -lt 1 ]; then
		let "current_line = 1"
	fi

	let "previous_line_number = $current_line - 1"
	if [ $previous_line_number -lt 1 ]; then
		let "previous_line_number = 1"
	fi
	let "next_line_number = $current_line + 1"
	if [ $next_line_number -gt $number_of_lines ]; then
		let "previous_line_number = $number_of_lines"
	fi

	lines_above=$(echo $output | sed -n "1,${previous_line_number}p")
	lines_below=$(echo $output | sed -n "${next_line_number},\$p")

	chosen_line=$(echo $output | sed "${current_line}q;d")
}

move_line() {
	update_position $current_line
	tput cup $current_line
	echo $chosen_line

	update_position $1
	tput rev
	tput cup $current_line
	echo $chosen_line

	tput sgr0
	tput cup $(tput lines)
	tput el
	printf "$(ls -ld $chosen_line)"
}


draw_screen() {
	tput clear
        tput civis

        if [ "$show_hidden" = 1 ]; then
                output=$(ls -A)
        else
                output=$(ls)
        fi

        tput bold
        echo $(pwd)
        tput sgr0

        let "number_of_lines=$(echo $output | wc -l)"
        echo $output

	if [ $1 ]; then
		let "current_line = $1"
	else
		let "current_line = 1"
	fi

	move_line $current_line
}

search_forward() {
	lines_down=$(echo $lines_below | sed -ne "/${pattern}/I=" | sed -n "1p")
	lines_from_top=$(echo $lines_above | sed -ne "/${pattern}/I=" | sed -n "1p")

	if [ $lines_down ]; then
		let "line_to_move_to = $current_line + $lines_down"
		move_line $line_to_move_to
	elif [ $lines_from_top ]; then
		move_line $lines_from_top
	fi
}

search_backward() {
	lines_up=$(echo $lines_above | sed -ne "/${pattern}/I=" | sed -n "\$p")
	lines_from_bottom=$(echo $lines_below | sed -ne "/${pattern}/I=" | sed -n "\$p")
	
	if [ $lines_up ]; then
		move_line $lines_up
	elif [ $lines_from_bottom ]; then
		let "line_to_move_to = $current_line + $lines_from_bottom"
		move_line $line_to_move_to
	fi
}

next() {
	if [ "$search_direction" = 1 ]; then
		search_forward
	else
		search_backward
	fi
}

find() {
	read -sk1 letter
	pattern='^'$letter
	next
}

search() {
	tput cup $(tput lines)
	tput el
	if [ "$search_direction" = 1 ]; then
		printf "/"
	else
		printf "?"
	fi
	tput cnorm
	read pattern
	next
	draw_screen $current_line
}

shell_command() {
	tput cup $(tput lines)
	tput el
	printf ":"
	tput cnorm
	read command_to_eval
	eval $command_to_eval
}

quit() {
	tput clear
	tput rmcup
	tput cnorm
	exit
}

read_keys() {
	draw_screen

	while true; do
		escape_char=$(printf "\u1b")
		read -sk1 key
		if [ $key = $escape_char ]; then
			read -sk2 key
		fi

		case $key in
			'j'|'[B'|$(printf '\ue'))
				move_line "$current_line + 1"
				;;
			'k'|'[A'|$(printf '\u10'))
				move_line "$current_line - 1"
				;;
			'g')
				move_line 0
				;;
			'G')
				move_line $number_of_lines
				;;
			'l'|'[C'|$(printf '\u6'))
				tput clear
				go_to $chosen_line
				draw_screen
				;;
			'h'|'[D'|$(printf '\u2'))
				tput clear
				go_to '..'
				draw_screen
				;;
			'z')
				((show_hidden ^= 1))
				draw_screen
				;;
			'~'|$(printf '\u8'))
				cd ~
				draw_screen
				;;
			'f')
				let "search_direction = 1"
				find
				;;
			'F')
				let "search_direction = 0"
				find
				;;
			'/')
				let "search_direction = 1"
				search
				;;
			'?')
				let "search_direction = 0"
				search
				;;
			'n')
				next
				;;
			'N')
				((search_direction ^= 1))
				next
				((search_direction ^= 1))
				;;
			':')
				shell_command
				draw_screen
				;;
			'q')
				quit
				return
				;;
		esac
	done
}

fm() {
	tput smcup
	let "show_hidden = 0"
	trap draw_screen SIGWINCH
	trap quit SIGINT
	read_keys $(pwd)
	if [ $1 ]; then
		pwd > $1
	fi
}

fm $1
