#!/bin/zsh

go_to() {
	case $(file $1) in
		*directory*)
			cd $1
			;;
		*text*)
			vim $1
			;;
		*)
			open $1
			;;
	esac
}

update_position() {
	let "current_line = $1"
	if [ $current_line -gt $number_of_lines ]; then
		let "current_line = $number_of_lines"
	elif [ $current_line -lt 1 ]; then
		let "current_line = 1"
	fi

	let "previous_line_number = $current_line - 1"
	if [ $previous_line_number -lt 1 ]; then
		let "previous_line_number = 1"
	fi
	let "next_line_number = $current_line + 1"
	if [ $next_line_number -gt $number_of_lines ]; then
		let "previous_line_number = $number_of_lines"
	fi

	lines_above=$(echo $output | sed -n "1,${previous_line_number}p")
	lines_below=$(echo $output | sed -n "${next_line_number},\$p")

	chosen_line=$(echo $output | sed "${current_line}q;d")
}

move_line() {
	update_position $current_line
	tput cup $current_line
	echo $chosen_line

	update_position $1
	tput rev
	tput cup $current_line
	echo $chosen_line

	tput sgr0
	tput cup $(tput lines)
	tput el
	printf "$(ls -ld $chosen_line)"
}


draw_screen() {
	tput clear
        tput civis

        if [ "$show_hidden" = 1 ]; then
                output=$(ls -A)
        else
                output=$(ls)
        fi

        tput bold
        echo $(pwd)
        tput sgr0

        let "current_line = 1"
        let "number_of_lines=$(echo $output | wc -l)"
        echo $output

	move_line $current_line
}

find_forward() {
	read -sk1 letter
	lines_down=$(echo $lines_below | sed -ne "/^${letter}/I=" | sed -n "1p")
	lines_from_top=$(echo $lines_above | sed -ne "/^${letter}/I=" | sed -n "1p")
	if [ $lines_down ]; then
		let "line_to_move_to = $current_line + $lines_down"
		move_line $line_to_move_to
	elif [ $lines_from_top ]; then
		move_line $lines_from_top
	fi
}

find_backward() {
	read -sk1 letter
	lines_up=$(echo $lines_above | sed -ne "/^${letter}/I=" | sed -n "\$p")
	lines_from_bottom=$(echo $lines_below | sed -ne "/^${letter}/I=" | sed -n "\$p")
	
	if [ $lines_up ]; then
		move_line $lines_up
	elif [ $lines_from_bottom ]; then
		let "line_to_move_to = $current_line + $lines_from_bottom"
		move_line $line_to_move_to
	fi
}

shell_command() {
	tput cup $(tput lines)
	tput el
	printf ":"
	tput cnorm
	read command_to_eval
	eval $command_to_eval
}

read_keys() {
	draw_screen

	while true; do
		escape_char=$(printf "\u1b")
		read -sk1 key
		if [ $key = $escape_char ]; then
			read -sk2 key
		fi

		case $key in
			'j'|'[B')
				move_line "$current_line + 1"
				;;
			'k'|'[A')
				move_line "$current_line - 1"
				;;
			'g')
				move_line 0
				;;
			'G')
				move_line $number_of_lines
				;;
			'l'|'[C')
				tput clear
				go_to $chosen_line
				draw_screen
				;;
			'h'|'[D')
				tput clear
				go_to '..'
				draw_screen
				;;
			'z')
				((show_hidden ^= 1))
				draw_screen
				;;
			'~')
				cd ~
				draw_screen
				;;
			'f')
				find_forward
				;;
			'F')
				find_backward
				;;
			':')
				shell_command
				draw_screen
				;;
			'q')
				tput clear
				tput rmcup
				return
				;;
		esac
	done
}

fm() {
	tput smcup
	let "show_hidden = 0"
	trap draw_screen WINCH
	read_keys $(pwd)
	if [ $1 ]; then
		pwd > $1
	fi
	tput cnorm
}

fm $1
