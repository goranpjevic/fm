#!/usr/bin/env zsh

go_to() {
	case $(file --dereference --brief $1) in
		*directory*)
			show_selected_files=0
			first_line_to_output=1
			cd $1
			draw_screen $2
			;;
		*text*)
			tput cnorm
			stty sane
			[ $EDITOR ] && $EDITOR $1 || vim $1 || vi $1 || nano $1 || ed $1
			draw_screen $current_line
			;;
		*)
			open $1 2>/dev/null
			;;
	esac
}

file_preview() {
	case $(file --dereference --brief $1) in
		*directory*)
			ls $([ "${show_hidden:=0}" = 1 ] && echo "-A") $1 2>/dev/null
			;;
		*text*)
			head -n $maximum_lines $1
			;;
		*)
			file --dereference --brief $1
			;;
	esac
}

print_preview() {
	empty_preview=$(printf "$(printf ' %.0s' {1..$maximum_line_width})\n%.0s" {1..$maximum_lines})
	tput cup 1 $maximum_line_width
	printf %s "$empty_preview" | PREFIX=$(tput cr; tput cuf $maximum_line_width) awk '{print ENVIRON["PREFIX"] $0}'

	preview_text=$(file_preview $1 | expand 2>/dev/null | cut -c 1-$maximum_line_width | sed -n "1,${maximum_lines}p")
	tput cup 1 $maximum_line_width
	printf %s "$preview_text" | PREFIX=$(tput cr; tput cuf $maximum_line_width) awk '{print ENVIRON["PREFIX"] $0}'
}

update_position() {
	let "current_line = $1"
	chosen_line=$(echo $output | sed "${current_line}q;d")

	if [ $current_line -gt $last_line_to_output ]; then
		let "first_line_to_output = $current_line - $maximum_lines + 1"
		actual_line=$maximum_lines
		draw_screen $current_line
	elif [ $current_line -lt $first_line_to_output ]; then
		let "first_line_to_output = $current_line"
		actual_line=1
		draw_screen $current_line
	else
		let "actual_line = $current_line - $first_line_to_output + 1"
	fi
}

move_line() {
	let "line_to_move_to = $1"
	if [ "$line_to_move_to" -le "$number_of_lines" ] && [ "$line_to_move_to" -ge "1" ]; then
		update_position $current_line
		tput cup $actual_line
		echo $chosen_line | cut -c 1-$(tput cols)

		update_position $1
		tput rev
		tput cup $actual_line
		echo $chosen_line | cut -c 1-$(tput cols)
		tput sgr0

		print_preview $chosen_line

		selected_file=$(echo $([ "$show_selected_files" = 0 ] && echo $(pwd)"/")$chosen_line | sed -e 's/[]\/$*.^[]/\\&/g')
		if [ $(echo $selected_lines | sed -n "/^${selected_file}\$/=") ]; then
			tput rev
		fi

		tput cup $(tput lines)
		tput el
		echo -n $(ls -ld $chosen_line | cut -c 1-$(tput cols))
		tput sgr0
	fi
}

draw_screen() {
	stty -echo
	tput clear
	tput civis

	tput bold
	if [ "${show_selected_files:=0}" = 0 ]; then
		output=$(file_preview "$(pwd)")

		echo $(pwd) | cut -c 1-$(tput cols)
	else
		output=$selected_lines

		echo "number of files selected: $(echo -n $selected_lines | grep -c '^')" | cut -c 1-$(tput cols)
	fi
	tput sgr0

	let "maximum_lines = $(tput lines) - 2"
	let "maximum_line_width = $(tput cols) / 2"
	let "number_of_lines=$(echo $output | wc -l)"
	let "last_line_to_output = ${first_line_to_output:=1} + $maximum_lines - 1"
	current_line=${1:=1}

	if [ $output ]; then
		echo $output | sed -n "${first_line_to_output},${last_line_to_output}p" | cut -c 1-$maximum_line_width
		move_line $current_line
	fi
}

go_to_parent_directory() {
	current_directory=$(basename "$(pwd)")
	if [ "$show_selected_files" = 0 ] && [ ! "$current_directory" = "/" ]; then
		go_to '..' $(file_preview "$(dirname "$(pwd)")" | sed -ne "/^$(echo $current_directory | sed -e 's/[]\/$*.^[]/\\&/g')\$/=")
	fi
}

toggle_hidden_files() {
	((show_hidden ^= 1))
	first_line_to_output=1
	selected_line=$chosen_line
	line_to_move_to=$(file_preview $(pwd) | sed -ne "/^${selected_line}\$/=")
	draw_screen $([ "$line_to_move_to" -gt 0 ] && echo $line_to_move_to)
}

next() {
	all_matches=$(echo $output | sed -ne "/${pattern:=.}/I=")
	below_matches=$(echo $all_matches | awk "\$1>${current_line}")
	above_matches=$(echo $all_matches | awk "\$1<${current_line}")
	sorted_matches="${below_matches}\n${above_matches}"
	if [ "${search_direction:=1}" = 0 ]; then
		sorted_matches=$(echo $sorted_matches | tail -r)
	fi
	line_to_move_to=$(echo $sorted_matches | sed "/^\s*$/d" | sed -n "1p")
	if [ $line_to_move_to ]; then
		move_line $line_to_move_to
	fi
}

find() {
	read -sk1 letter
	pattern='^'$(echo $letter | sed -e 's/[]\/$*.^[]/\\&/g')
	next
}

user_input() {
	stty sane
	tput cup $(tput lines)
	tput el
	echo -n $key
	tput cnorm
	read -r $1
}

search() {
	user_input pattern
	next
	draw_screen $current_line
}

select_file() {
	if [ $output ]; then
		file_to_select=$([ "$show_selected_files" = 0 ] && echo $(pwd)"/")$1
		if [ "$(echo $selected_lines | sed -n "/^$(echo $file_to_select | sed -e 's/[]\/$*.^[]/\\&/g')$/=")" ]; then
			selected_lines=$(echo $selected_lines | sed "/^$(echo $file_to_select | sed -e 's/[]\/$*.^[]/\\&/g')$/d")
		else
			selected_lines=$(echo "$selected_lines""\n""$file_to_select" | sed "/^\s*$/d")
		fi
		move_line $current_line
	fi
}

copy_or_move() {
	if [ $selected_lines ] && [ "$show_selected_files" = 0 ]; then
		tput cup $(tput lines)
		tput el
		echo -n "are you sure you want to $1 the selected files to the current directory? [y/N]"
		read -sq answer
		if [ $answer = "y" ]; then
			selected_lines_array=(${(f)selected_lines})
			selection_action=$([ $1 = "copy" ] && echo "cp -R" || echo "mv")
			for one_selected_line in $selected_lines_array; do
				eval $selection_action '"'$one_selected_line'"' .
			done
			selected_lines=
		fi
		draw_screen
	fi
}

shell_command() {
	user_input command_to_eval
	eval $command_to_eval
	draw_screen
}

fuzzy_find() {
	go_to "$(fzf --preview 'case $(file {}) in *directory*) ls -la {} ;; *text*) cat {} ;; *) file {} ;; esac')"
	draw_screen
}

quit() {
	tput clear
	tput rmcup
	tput cnorm
	stty sane
	if [ $1 ]; then
		pwd >> $1
	fi
	exit
}

read_keys() {
	while true; do
		escape_char=$'\u1b'
		read -sk1 key
		if [ $key = $escape_char ]; then
			read -sk2 key
		fi

		case $key in
			'j'|'[B'|$'\ue')
				move_line "$current_line + 1"
				;;
			'k'|'[A'|$'\u10')
				move_line "$current_line - 1"
				;;
			'g')
				move_line 1
				;;
			'G')
				move_line $number_of_lines
				;;
			'l'|'[C'|$'\u6')
				go_to $chosen_line
				;;
			'h'|'[D'|$'\u2')
				go_to_parent_directory
				;;
			'z')
				toggle_hidden_files
				;;
			'~'|$'\u8')
				go_to $HOME
				;;
			'b')
				bookmarked_directory="$(pwd)"
				;;
			"'")
				if [ $bookmarked_directory ]; then
					go_to "$bookmarked_directory"
				fi
				;;
			'f')
				let "search_direction = 1"
				find
				;;
			'F')
				let "search_direction = 0"
				find
				;;
			'/')
				let "search_direction = 1"
				search
				;;
			'?')
				let "search_direction = 0"
				search
				;;
			'n')
				next
				;;
			'N')
				((search_direction ^= 1))
				next
				((search_direction ^= 1))
				;;
			'e'|$'\ub')
				fuzzy_find
				;;
			's'|' ')
				select_file $chosen_line
				;;
			't')
				((show_selected_files ^= 1))
				draw_screen
				;;
			'c')
				copy_or_move "copy"
				;;
			'm')
				copy_or_move "move"
				;;
			':')
				shell_command
				;;
			'q')
				quit $1
				;;
		esac
	done
}

fm() {
	tput smcup
	trap 'draw_screen $current_line' SIGWINCH
	trap 'quit $2' SIGINT
	go_to ${1:=.}
	read_keys $2
}

fm $@
