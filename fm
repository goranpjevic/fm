#!/bin/zsh

go_to() {
	case $(file --brief $1) in
		*directory*)
			cd $1
			;;
		*text*)
			vim $1
			;;
		*)
			open $1
			;;
	esac
}

file_preview() {
	case $(file $1) in
		*directory*)
			if [ "$show_hidden" = 1 ]; then
				ls -lA $1 2>/dev/null
			else
				ls -l $1 2>/dev/null
			fi
			;;
		*text*)
			cat $1
			;;
		*)
			file --brief $1
			;;
	esac
}

print_preview() {
	let "preview_line_length = $(tput cols) - 100"
	preview_text=$(file_preview $1 | cut -c 1-$preview_line_length)
	for ((i = 0; i < $maximum_lines; ++i)); do
		tput cup $i 100
		tput el
		echo $preview_text | sed "${i}q;d"
	done
}

update_position() {
	let "current_line = $1"
	if [ $current_line -gt $number_of_lines ]; then
		let "current_line = $number_of_lines"
	elif [ $current_line -lt 1 ]; then
		let "current_line = 1"
	fi

	let "previous_line_number = $current_line - 1"
	let "next_line_number = $current_line + 1"

	if [ "$previous_line_number" = 0 ]; then
		lines_above=""
	else
		lines_above=$(echo $output | sed -n "1,${previous_line_number}p")
	fi
	if [ $next_line_number = $number_of_lines ]; then
		lines_below=""
	else
		lines_below=$(echo $output | sed -n "${next_line_number},\$p")
	fi

	chosen_line=$(echo $output | sed "${current_line}q;d")

	if [ $current_line -gt $last_line_to_output ]; then
		let "first_line_to_output = $current_line - $maximum_lines + 1"
		actual_line=$maximum_lines
		draw_screen $current_line
	elif [ $current_line -lt $first_line_to_output ]; then
		let "first_line_to_output = $current_line"
		actual_line=1
		draw_screen $current_line
	else
		let "actual_line = $current_line - $first_line_to_output + 1"
	fi
}

move_line() {
	update_position $current_line
	tput cup $actual_line
	echo $chosen_line | cut -c 1-$(tput cols)

	update_position $1
	tput rev
	tput cup $actual_line
	echo $chosen_line | cut -c 1-$(tput cols)

	tput sgr0
	if [ "$enable_preview" = 1 ] && [ "$show_previews" = 1 ]; then
		print_preview $chosen_line
	fi

	tput cup $(tput lines)
	tput el
	echo -n $(ls -ld $chosen_line | cut -c 1-$(tput cols))
}


draw_screen() {
	tput clear
	tput civis

	let "show_previews = 0"
	let "maximum_content_line_width = $(tput cols)"
	if [ "$(tput cols)" -gt 150 ]; then
		let "show_previews = 1"
		let "maximum_content_line_width = 100"
	fi

	if [ "$show_hidden" = 1 ]; then
		output=$(ls -A)
	else
		output=$(ls)
	fi

	tput bold
	echo $(pwd) | cut -c 1-$(tput cols)
	tput sgr0

	let "maximum_lines = $(tput lines) - 2"
	let "number_of_lines=$(echo $output | wc -l)"
	if [ -z $first_line_to_output ]; then
		let "first_line_to_output = 1"
	fi
	let "last_line_to_output = $first_line_to_output + $maximum_lines - 1"
	echo $output | sed -n "${first_line_to_output},${last_line_to_output}p" | cut -c 1-$maximum_content_line_width

	current_line=${1:=1}

	move_line $current_line
}

go_to_parent_directory() {
	current_directory_name=${PWD##*/}
	if [ $current_directory_name ]; then
		go_to '..'
		if [ "$show_hidden" = 1 ]; then
			line_to_move_to=$(ls -A | sed -ne "/^${current_directory_name}\$/=")
		else
			line_to_move_to=$(ls | sed -ne "/^${current_directory_name}\$/=")
		fi
		draw_screen $line_to_move_to
	fi
}

toggle_hidden_files() {
	((show_hidden ^= 1))
	selected_line=$chosen_line
	draw_screen
	line_to_move_to=$(echo $output | sed -ne "/^${selected_line}\$/=")
	if [ $line_to_move_to ]; then
		move_line $line_to_move_to
	fi
}

next() {
	if [ "$search_direction" = 1 ]; then
		match_to_take="1"
	else
		match_to_take="\$"
	fi

	down_next_match=
	up_next_match=
	down_next_match=$(echo $lines_below | sed -ne "/${pattern}/I=" | sed -n "${match_to_take}p")
	up_next_match=$(echo $lines_above | sed -ne "/${pattern}/I=" | sed -n "${match_to_take}p")

	if [ "$search_direction" = 1 ]; then
		if [ $down_next_match ]; then
			move_line "$current_line + $down_next_match"
		elif [ $up_next_match ]; then
			move_line $up_next_match
		fi
	else
		if [ $up_next_match ]; then
			move_line $up_next_match
		elif [ $down_next_match ]; then
			move_line "$current_line + $down_next_match"
		fi
	fi
}

find() {
	read -sk1 letter
	pattern='^'$letter
	next
}

search() {
	tput cup $(tput lines)
	tput el
	if [ "$search_direction" = 1 ]; then
		printf "/"
	else
		printf "?"
	fi
	tput cnorm
	read pattern
	next
	draw_screen $current_line
}

shell_command() {
	tput cup $(tput lines)
	tput el
	printf ":"
	tput cnorm
	read command_to_eval
	eval $command_to_eval
}

fuzzy_find() {
	go_to $(fzf --preview 'case $(file {}) in *directory*) ls -la {} ;; *text*) cat {} ;; *) file {} ;; esac')
}

quit() {
	tput clear
	tput rmcup
	tput cnorm
	if [ $1 ]; then
		pwd >> $1
	fi
	exit
}

read_keys() {
	draw_screen

	while true; do
		escape_char=$(printf "\u1b")
		read -sk1 key
		if [ $key = $escape_char ]; then
			read -sk2 key
		fi

		case $key in
			'j'|'[B'|$(printf '\ue'))
				move_line "$current_line + 1"
				;;
			'k'|'[A'|$(printf '\u10'))
				move_line "$current_line - 1"
				;;
			'g')
				move_line 0
				;;
			'G')
				move_line $number_of_lines
				;;
			'l'|'[C'|$(printf '\u6'))
				go_to $chosen_line
				draw_screen
				;;
			'h'|'[D'|$(printf '\u2'))
				go_to_parent_directory
				;;
			'z')
				toggle_hidden_files
				;;
			'~'|$(printf '\u8'))
				cd ~
				draw_screen
				;;
			'f')
				let "search_direction = 1"
				find
				;;
			'F')
				let "search_direction = 0"
				find
				;;
			'/')
				let "search_direction = 1"
				search
				;;
			'?')
				let "search_direction = 0"
				search
				;;
			'n')
				next
				;;
			'N')
				((search_direction ^= 1))
				next
				((search_direction ^= 1))
				;;
			'e'|$(printf '\ub'))
				fuzzy_find
				draw_screen
				;;
			':')
				shell_command
				draw_screen
				;;
			'q')
				quit $2
				return
				;;
		esac
	done
}

fm() {
	cd ${1:=.}

	tput smcup
	let "show_hidden = 0"
	let "enable_preview = 0"
	trap 'draw_screen' SIGWINCH
	trap 'quit $2' SIGINT
	read_keys $(pwd) $2
}

fm $@
