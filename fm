#!/bin/zsh

go_to() {
	case $(file --brief $1) in
		*directory*)
			show_selected_files=0
			cd $1
			;;
		*text*)
			vim $1
			;;
		*)
			open $1
			;;
	esac
}

file_preview() {
	case $(file --brief $1) in
		*directory*)
			ls $([ "${show_hidden:=0}" = 1 ] && echo "-A") $1 2>/dev/null
			;;
		*text*)
			cat $1 | expand
			;;
		*)
			file --brief $1
			;;
	esac
}

print_preview() {
	empty_preview=$(printf "$(printf ' %.0s' {1..$maximum_line_width})\n%.0s" {1..$maximum_lines})
	tput cup 1 $maximum_line_width
	printf %s "$empty_preview" | PREFIX=$(tput cr; tput cuf $maximum_line_width) awk '{print ENVIRON["PREFIX"] $0}'

	preview_text=$(file_preview $1 | cut -c 1-$maximum_line_width | sed -n "1,${maximum_lines}p")
	tput cup 1 $maximum_line_width
	printf %s "$preview_text" | PREFIX=$(tput cr; tput cuf $maximum_line_width) awk '{print ENVIRON["PREFIX"] $0}'
}

update_position() {
	let "current_line = $1"

	chosen_line=$(echo $output | sed "${current_line}q;d")

	if [ $current_line -gt $last_line_to_output ]; then
		let "first_line_to_output = $current_line - $maximum_lines + 1"
		actual_line=$maximum_lines
		draw_screen $current_line
	elif [ $current_line -lt $first_line_to_output ]; then
		let "first_line_to_output = $current_line"
		actual_line=1
		draw_screen $current_line
	else
		let "actual_line = $current_line - $first_line_to_output + 1"
	fi
}

move_line() {
	let "line_to_move_to = $1"
	if [ "$line_to_move_to" -le "$number_of_lines" ] && [ "$line_to_move_to" -ge "1" ]; then
		update_position $current_line
		tput cup $actual_line
		echo $chosen_line | cut -c 1-$(tput cols)

		update_position $1
		tput rev
		tput cup $actual_line
		echo $chosen_line | cut -c 1-$(tput cols)

		tput sgr0
		print_preview $chosen_line

		selected_file=$(echo $([ "$show_selected_files" = 0 ] && echo $(pwd)"/")$chosen_line | sed -e 's/[]\/$*.^[]/\\&/g')
		if [ $(echo $selected_lines | sed -n "/${selected_file}/=") ]; then
			tput rev
		fi

		tput cup $(tput lines)
		tput el
		echo -n $(ls -ld $chosen_line | cut -c 1-$(tput cols))
		tput sgr0
	fi
}


draw_screen() {
	tput clear
	tput civis

	tput bold
	if [ "${show_selected_files:=0}" = 0 ]; then
		output=$(file_preview $(pwd))

		echo $(pwd) | cut -c 1-$(tput cols)
	else
		output=$selected_lines

		top_line="number of files selected: "
		if [ $selected_lines ]; then
			top_line+=$(echo $selected_lines | wc -l | sed 's/ //g')
		else
			top_line+="0"
		fi
		top_line+="  action:"
		top_line+=$selection_option
		echo $top_line | cut -c 1-$(tput cols)
	fi
	tput sgr0

	let "maximum_lines = $(tput lines) - 2"
	let "number_of_lines=$(echo $output | wc -l)"
	let "last_line_to_output = ${first_line_to_output:=1} + $maximum_lines - 1"
	current_line=${1:=1}

	let "maximum_line_width = $(tput cols) / 2"

	if [ $output ]; then
		echo $output | sed -n "${first_line_to_output},${last_line_to_output}p" | cut -c 1-$maximum_line_width
		move_line $current_line
	fi
}

go_to_parent_directory() {
	current_directory_name=${PWD##*/}
	if [ "$show_selected_files" = 0 ] && [ $current_directory_name ]; then
		go_to '..'
		line_to_move_to=$(file_preview $(pwd) | sed -ne "/^$(echo $current_directory_name | sed -e 's/[]\/$*.^[]/\\&/g')\$/=")
		if [ "$line_to_move_to" = 0 ]; then
			draw_screen
		else
			draw_screen $line_to_move_to
		fi
	fi
}

toggle_hidden_files() {
	((show_hidden ^= 1))
	selected_line=$chosen_line
	line_to_move_to=$(file_preview $(pwd) | sed -ne "/^${selected_line}\$/=")
	draw_screen $([ "$line_to_move_to" -gt 0 ] && echo $line_to_move_to)
}

next() {
	all_matches=$(echo $output | sed -ne "/${pattern:=.}/I=")
	below_matches=$(echo $all_matches | awk "\$1>${current_line}")
	above_matches=$(echo $all_matches | awk "\$1<${current_line}")
	sorted_matches="${below_matches}\n${above_matches}"
	if [ "${search_direction:=1}" = 0 ]; then
		sorted_matches=$(echo $sorted_matches | tail -r)
	fi
	line_to_move_to=$(echo $sorted_matches | sed "/^\s*$/d" | sed -n "1p")
	if [ $line_to_move_to ]; then
		move_line $line_to_move_to
	fi
}

find() {
	read -sk1 letter
	pattern='^'$letter
	next
}

search() {
	tput cup $(tput lines)
	tput el
	if [ "$search_direction" = 1 ]; then
		printf "/"
	else
		printf "?"
	fi
	tput cnorm
	read pattern
	next
	draw_screen $current_line
}

select_file() {
	if [ "$show_selected_files" = 1 ]; then
		file_to_select=$1
	else
		file_to_select=$(echo "$(pwd)""/""$1")
	fi
	if [ "$(echo $selected_lines | sed -n "/$(echo $file_to_select | sed -e 's/[]\/$*.^[]/\\&/g')/=")" ]; then
		selected_lines=$(echo $selected_lines | sed "/$(echo $file_to_select | sed -e 's/[]\/$*.^[]/\\&/g')/d")
	else
		selected_lines=$(echo "$selected_lines""\n""$file_to_select" | sed "/^\s*$/d")
	fi
	move_line $current_line
}

paste_selected_files() {
	if [ "$selection_option" = "move" ]; then
		selection_action="mv"
	elif [ "$selection_option" = "copy" ]; then
		selection_action="cp"
	else
		return
	fi

	selected_lines_array=(${(f)selected_lines})
	for one_selected_line in $selected_lines_array; do
		$selection_action $one_selected_line .
	done

	selected_lines=
	selection_option=
	draw_screen
}

shell_command() {
	tput cup $(tput lines)
	tput el
	printf ":"
	tput cnorm
	read command_to_eval
	eval $command_to_eval
}

fuzzy_find() {
	go_to $(fzf --preview 'case $(file {}) in *directory*) ls -la {} ;; *text*) cat {} ;; *) file {} ;; esac')
}

quit() {
	tput clear
	tput rmcup
	tput cnorm
	if [ $1 ]; then
		pwd >> $1
	fi
	exit
}

read_keys() {
	while true; do
		escape_char=$(printf "\u1b")
		read -sk1 key
		if [ $key = $escape_char ]; then
			read -sk2 key
		fi

		case $key in
			'j'|'[B'|$(printf '\ue'))
				move_line "$current_line + 1"
				;;
			'k'|'[A'|$(printf '\u10'))
				move_line "$current_line - 1"
				;;
			'g')
				move_line 1
				;;
			'G')
				move_line $number_of_lines
				;;
			'l'|'[C'|$(printf '\u6'))
				current_path=$(pwd)
				go_to $chosen_line
				if [ $current_path = $(pwd) ]; then
					draw_screen $current_line
				else
					draw_screen
				fi
				;;
			'h'|'[D'|$(printf '\u2'))
				go_to_parent_directory
				;;
			'z')
				toggle_hidden_files
				;;
			'~'|$(printf '\u8'))
				cd ~
				draw_screen
				;;
			'f')
				let "search_direction = 1"
				find
				;;
			'F')
				let "search_direction = 0"
				find
				;;
			'/')
				let "search_direction = 1"
				search
				;;
			'?')
				let "search_direction = 0"
				search
				;;
			'n')
				next
				;;
			'N')
				((search_direction ^= 1))
				next
				((search_direction ^= 1))
				;;
			'e'|$(printf '\ub'))
				fuzzy_find
				draw_screen
				;;
			's'|' ')
				select_file $chosen_line
				;;
			't')
				((show_selected_files ^= 1))
				draw_screen
				;;
			'd')
				selection_option="move"
				draw_screen $current_line
				;;
			'y')
				selection_option="copy"
				draw_screen $current_line
				;;
			'p')
				paste_selected_files
				;;
			':')
				shell_command
				draw_screen
				;;
			'q')
				quit $2
				;;
		esac
	done
}

fm() {
	cd ${1:=.}

	tput smcup
	trap 'draw_screen $current_line' SIGWINCH
	trap 'quit $2' SIGINT
	draw_screen
	read_keys $(pwd) $2
}

fm $@
